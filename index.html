<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Two Column Layout</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <div class="columns-wrapper">
            <div class="left-column" id="leftColumn">
                <!-- Sections will be dynamically generated -->
                <div class="dumbbell">
                    <div class="dumbbell-weight"></div>
                    <div class="dumbbell-bar"></div>
                    <div class="dumbbell-weight"></div>
                </div>
            </div>
            <div class="right-column">
                <div class="stats-section">
                    <div class="stat-item">
                        <div class="stat-label">XP</div>
                        <div class="stat-value" id="strengthValue">0</div>
                        <div class="stat-hint">Tap and release the dumbbell over 'Gains' to gain XP.</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Weight</div>
                        <div class="stat-value" id="weightValue">50</div>
                        <div class="stat-hint">Increase your XP to lift more weight and earn rewards.</div>
                    </div>
                </div>

                <div class="status-effects-section">
                    <div class="status-effects-title">Status Effects</div>
                    <div class="effects-list" id="effectsList">
                        <!-- Effects will be dynamically added here -->
                    </div>
                </div>
            </div>
        </div>
        
        <div class="button-container">
            <button class="add-weight-button" id="addWeightButton" disabled>
                <span>Add Weight</span>
                <span class="button-subtext">Requires 20 XP</span>
            </button>
            <button class="lift-button" id="liftButton">
                <span>Lift</span>
                <span class="button-subtext">Tap and hold</span>
            </button>
        </div>
    </div>

    <div class="debug-menu" id="debugMenu">
        <div class="debug-title">Debug Menu</div>
        <button class="debug-button" id="expireEffectsButton">Expire All Effects</button>
    </div>

    <script>
        const dumbbell = document.querySelector('.dumbbell');
        const liftButton = document.getElementById('liftButton');
        const addWeightButton = document.getElementById('addWeightButton');
        const strengthValue = document.getElementById('strengthValue');
        const weightValue = document.getElementById('weightValue');
        const effectsList = document.getElementById('effectsList');
        const debugMenu = document.getElementById('debugMenu');
        const expireEffectsButton = document.getElementById('expireEffectsButton');
        const leftColumn = document.getElementById('leftColumn');
        
        let isLifting = false;
        let isLowering = false;
        let startTime = null;
        let animationFrame = null;
        let currentPosition = 75; // Track current position
        let liftStartPosition = 75; // Track where lift started from
        let strength = 0;
        let weight = 50;
        let liftStartSection = null;
        let fatigueStacks = 0;
        let fatigueTimeRemaining = 0;
        let fatigueTimerInterval = null;
        let autoDropTimer = null;
        let perfectionStacks = 0;
        let perfectionTimeRemaining = 0;
        let perfectionTimerInterval = null;
        let statusEffectDefs = {};
        let levelsConfig = null;
        let currentLevel = null;
        let currentLevelNumber = 1;
        
        // Debug menu state
        const debugSequence = ['ArrowUp', 'ArrowDown', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
        let debugInput = [];

        // Load configurations
        Promise.all([
            fetch('statusEffects.json').then(r => r.json()),
            fetch('levels.json').then(r => r.json())
        ]).then(([effectsData, levelsData]) => {
            statusEffectDefs = effectsData;
            levelsConfig = levelsData;
            loadLevel(1);
        }).catch(error => console.error('Error loading configurations:', error));

        function loadLevel(levelNum) {
            const levelData = levelsConfig.levels.find(l => l.levelNumber === levelNum);
            if (!levelData) {
                console.error('Level not found:', levelNum);
                return;
            }
            
            currentLevel = levelData;
            currentLevelNumber = levelNum;
            weight = levelData.weight;
            weightValue.textContent = weight;
            
            // Render sections
            renderSections(levelData.sections);
        }

        function renderSections(sections) {
            // Clear existing sections (but keep dumbbell)
            const dumbbellElement = leftColumn.querySelector('.dumbbell');
            leftColumn.innerHTML = '';
            
            // Create sections
            sections.forEach(section => {
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'section';
                
                if (section.type === 'perfection') {
                    sectionDiv.classList.add('perfection');
                }
                
                sectionDiv.setAttribute('data-type', section.type);
                
                // Apply styling
                if (section.flex) {
                    sectionDiv.style.flex = section.flex;
                } else if (section.height) {
                    sectionDiv.style.flex = '0 0 ' + section.height + 'px';
                }
                
                if (section.backgroundColor && section.type === 'perfection') {
                    sectionDiv.style.background = section.backgroundColor;
                }
                
                // Add title
                const titleDiv = document.createElement('div');
                titleDiv.className = 'section-title';
                titleDiv.textContent = section.label;
                sectionDiv.appendChild(titleDiv);
                
                leftColumn.appendChild(sectionDiv);
            });
            
            // Re-add dumbbell at the end
            leftColumn.appendChild(dumbbellElement);
        }

        function updateEffectsDisplay() {
            if (fatigueStacks === 0 && perfectionStacks === 0) {
                effectsList.innerHTML = `
                    <div class="effect-description" style="padding: 12px 0;">
                        You currently have no conditions that affect your lifting abilities
                    </div>
                `;
                return;
            }

            let effectsHTML = '';

            if (perfectionStacks > 0 && statusEffectDefs.perfection) {
                const def = statusEffectDefs.perfection;
                const stackText = perfectionStacks > 1 ? ` x${perfectionStacks}` : '';
                const percentage = perfectionStacks * 25;
                const description = def.description.replace('25%', `${percentage}%`);
                effectsHTML += `
                    <div class="effect-item" style="border-left-color: ${def.color};">
                        <div class="effect-header">
                            <div class="effect-name">${def.name}${stackText}</div>
                            <div class="effect-timer" id="perfectionTimer" style="color: ${def.color};">${perfectionTimeRemaining}s</div>
                        </div>
                        <div class="effect-description">${description}</div>
                    </div>
                `;
            }

            if (fatigueStacks > 0 && statusEffectDefs.fatigue) {
                const def = statusEffectDefs.fatigue;
                const stackText = fatigueStacks > 1 ? ` x${fatigueStacks}` : '';
                const percentage = Math.min(fatigueStacks * 10, 100);
                const description = def.description.replace('{percentage}', percentage);
                effectsHTML += `
                    <div class="effect-item" style="border-left-color: ${def.color};">
                        <div class="effect-header">
                            <div class="effect-name">${def.name}${stackText}</div>
                            <div class="effect-timer" id="fatigueTimer" style="color: ${def.color};">${fatigueTimeRemaining}s</div>
                        </div>
                        <div class="effect-description">${description}</div>
                    </div>
                `;
            }
            
            effectsList.innerHTML = effectsHTML;
        }

        function addFatigueStack() {
            const def = statusEffectDefs.fatigue;
            if (!def || fatigueStacks >= def.maxStacks) return;
            
            fatigueStacks++;
            fatigueTimeRemaining += def.duration;
            
            // Cap total duration at max
            if (fatigueTimeRemaining > def.maxDuration) {
                fatigueTimeRemaining = def.maxDuration;
            }
            
            updateEffectsDisplay();
            
            // Start timer if not already running
            if (!fatigueTimerInterval) {
                fatigueTimerInterval = setInterval(() => {
                    if (fatigueTimeRemaining > 0) {
                        fatigueTimeRemaining--;
                        const timerEl = document.getElementById('fatigueTimer');
                        if (timerEl) {
                            timerEl.textContent = fatigueTimeRemaining + 's';
                        }
                    } else {
                        fatigueStacks = 0;
                        clearInterval(fatigueTimerInterval);
                        fatigueTimerInterval = null;
                        updateEffectsDisplay();
                    }
                }, 1000);
            }
        }

        function addPerfectionEffect() {
            const def = statusEffectDefs.perfection;
            if (!def || perfectionStacks >= def.maxStacks) return;
            
            perfectionStacks++;
            perfectionTimeRemaining += def.duration;
            
            // Cap total duration at max
            if (perfectionTimeRemaining > def.maxDuration) {
                perfectionTimeRemaining = def.maxDuration;
            }
            
            updateEffectsDisplay();
            
            // Start timer if not already running
            if (!perfectionTimerInterval) {
                perfectionTimerInterval = setInterval(() => {
                    if (perfectionTimeRemaining > 0) {
                        perfectionTimeRemaining--;
                        const timerEl = document.getElementById('perfectionTimer');
                        if (timerEl) {
                            timerEl.textContent = perfectionTimeRemaining + 's';
                        }
                    } else {
                        perfectionStacks = 0;
                        clearInterval(perfectionTimerInterval);
                        perfectionTimerInterval = null;
                        updateEffectsDisplay();
                    }
                }, 1000);
            }
        }

        // Calculate which section the dumbbell is in
        function getCurrentSection() {
            const columnHeight = leftColumn.clientHeight;
            const positionFromTop = columnHeight - currentPosition;
            
            const sections = leftColumn.querySelectorAll('.section');
            let cumulativeHeight = 0;
            
            for (let i = 0; i < sections.length; i++) {
                const sectionHeight = sections[i].clientHeight;
                if (positionFromTop >= cumulativeHeight && positionFromTop < cumulativeHeight + sectionHeight) {
                    const sectionType = sections[i].getAttribute('data-type');
                    if (sectionType === 'perfection') {
                        return 'perfection';
                    } else if (sectionType === 'fatigue') {
                        return 'fatigue';
                    } else if (sectionType === 'gains') {
                        // Differentiate between first and last gains section
                        return i === 0 ? 'gains-top' : 'gains-bottom';
                    }
                }
                cumulativeHeight += sectionHeight;
            }
            
            return 'gains-bottom'; // Default
        }

        function isInGainsSection(section) {
            return section === 'gains-top' || section === 'gains-bottom';
        }

        function updateAddWeightButton() {
            if (strength >= 20) {
                addWeightButton.disabled = false;
            } else {
                addWeightButton.disabled = true;
            }
        }

        function animateLift(timestamp) {
            if (!isLifting) return;
            
            if (!startTime) startTime = timestamp;
            const elapsed = timestamp - startTime;
            
            // Calculate max height considering fatigue
            const baseMaxHeight = window.innerHeight - 100;
            const minHeight = 75;
            const totalLiftableDistance = baseMaxHeight - minHeight;
            const fatigueReduction = Math.min(fatigueStacks * 10, 100) / 100; // 10% per stack, max 100%
            const maxLiftableDistance = totalLiftableDistance * (1 - fatigueReduction);
            const endPos = minHeight + maxLiftableDistance;
            
            const distanceToTravel = endPos - liftStartPosition;
            const totalDistance = baseMaxHeight - 75;
            const duration = 1500 * (distanceToTravel / totalDistance); // Scale duration to remaining distance
            
            let progress = Math.min(elapsed / duration, 1);
            progress = 1 - Math.pow(1 - progress, 3); // Cubic ease-out for smooth motion
            
            // Move from lift start position to max allowed position
            currentPosition = liftStartPosition + (endPos - liftStartPosition) * progress;
            
            dumbbell.style.bottom = `${currentPosition}px`;
            
            if (progress < 1) {
                animationFrame = requestAnimationFrame(animateLift);
            } else {
                // Bar has reached the top, start 1-second timer for auto-drop
                if (!autoDropTimer && isLifting) {
                    autoDropTimer = setTimeout(() => {
                        stopLift();
                    }, 1000);
                }
            }
        }

        function animateLower(timestamp) {
            if (!isLowering) return;
            
            if (!startTime) startTime = timestamp;
            const elapsed = timestamp - startTime;
            
            // Use ease-in cubic for smooth acceleration downward
            const duration = 1125; // 1.125 seconds to return to bottom
            let progress = Math.min(elapsed / duration, 1);
            progress = Math.pow(progress, 2); // Quadratic ease-in for smooth drop
            
            // Move from current position back to 75px
            const startPos = currentPosition;
            const endPos = 75;
            currentPosition = startPos + (endPos - startPos) * progress;
            
            dumbbell.style.bottom = `${currentPosition}px`;
            
            if (progress < 1) {
                animationFrame = requestAnimationFrame(animateLower);
            } else {
                isLowering = false;
                currentPosition = 75;
            }
        }

        function startLift() {
            // Cancel any ongoing animation
            if (animationFrame) cancelAnimationFrame(animationFrame);
            
            // Clear auto-drop timer if exists
            if (autoDropTimer) {
                clearTimeout(autoDropTimer);
                autoDropTimer = null;
            }
            
            // Check if starting in Fatigue section
            const startSection = getCurrentSection();
            if (startSection === 'fatigue') {
                addFatigueStack();
            } else if (startSection === 'perfection') {
                addPerfectionEffect();
            }
            
            // Add visual feedback
            liftButton.classList.add('lifting');
            dumbbell.classList.add('shaking');
            
            // Record which section we're starting in
            liftStartSection = startSection;
            
            // Start lifting from current position
            isLifting = true;
            isLowering = false;
            startTime = null;
            liftStartPosition = currentPosition; // Resume from wherever we are now
            
            animationFrame = requestAnimationFrame(animateLift);
        }

        function stopLift() {
            if (animationFrame) cancelAnimationFrame(animationFrame);
            
            // Clear auto-drop timer if exists
            if (autoDropTimer) {
                clearTimeout(autoDropTimer);
                autoDropTimer = null;
            }
            
            // Remove lifting state
            liftButton.classList.remove('lifting');
            dumbbell.classList.remove('shaking');
            
            // Check if we released in Fatigue section
            const releaseSection = getCurrentSection();
            if (releaseSection === 'fatigue') {
                addFatigueStack();
            } else if (releaseSection === 'perfection') {
                addPerfectionEffect();
            }
            
            // Check if we started and ended in different Gains sections
            if (isInGainsSection(liftStartSection) && 
                isInGainsSection(releaseSection) && 
                liftStartSection !== releaseSection) {
                let xpGain = currentLevel ? currentLevel.baseXP : 5;
                if (perfectionStacks > 0) {
                    xpGain = Math.floor(xpGain * (1 + (perfectionStacks * 0.25))); // 25% bonus per stack
                }
                strength += xpGain;
                strengthValue.textContent = strength;
                updateAddWeightButton();
                
                // Add success feedback
                liftButton.classList.add('success');
                setTimeout(() => {
                    liftButton.classList.remove('success');
                }, 400);
            }
            
            // Start lowering from current position
            isLifting = false;
            isLowering = true;
            startTime = null;
            
            animationFrame = requestAnimationFrame(animateLower);
        }

        // Mouse events
        liftButton.addEventListener('mousedown', startLift);
        liftButton.addEventListener('mouseup', stopLift);
        liftButton.addEventListener('mouseleave', stopLift);

        // Touch events
        liftButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startLift();
        });
        liftButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopLift();
        });
        liftButton.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            stopLift();
        });

        // Debug menu keyboard sequence detection
        document.addEventListener('keydown', (e) => {
            debugInput.push(e.key);
            
            // Keep only the last 6 keys
            if (debugInput.length > debugSequence.length) {
                debugInput.shift();
            }
            
            // Check if sequence matches
            if (debugInput.length === debugSequence.length) {
                const matches = debugInput.every((key, index) => key === debugSequence[index]);
                if (matches) {
                    debugMenu.classList.toggle('visible');
                    debugInput = []; // Reset sequence
                }
            }
        });

        // Expire all effects button
        expireEffectsButton.addEventListener('click', () => {
            fatigueTimeRemaining = 0;
            fatigueStacks = 0;
            if (fatigueTimerInterval) {
                clearInterval(fatigueTimerInterval);
                fatigueTimerInterval = null;
            }
            perfectionTimeRemaining = 0;
            perfectionStacks = 0;
            if (perfectionTimerInterval) {
                clearInterval(perfectionTimerInterval);
                perfectionTimerInterval = null;
            }
            updateEffectsDisplay();
        });

        // Initialize display on page load
        updateEffectsDisplay();
    </script>
</body>
</html>