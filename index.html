<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Two Column Layout</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <div class="columns-wrapper">
            <div class="left-column" id="leftColumn">
                <!-- Sections will be dynamically generated -->
                <div class="dumbbell">
                    <div class="dumbbell-weight"></div>
                    <div class="dumbbell-bar"></div>
                    <div class="dumbbell-weight"></div>
                </div>
            </div>
            <div class="right-column">
                <div class="stats-section">
                    <div class="stat-item">
                        <div class="stat-label">Weight</div>
                        <div class="stat-value" id="weightValue">50/500</div>
                        <div class="stat-hint">Do you have what it takes to bench press 500 lbs?</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Reps</div>
                        <div class="stat-value" id="repsValue">0/5</div>
                        <div class="stat-hint">Move the dumbbell between "Gains" sections <strong>without</strong> resting.</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">XP</div>
                        <div class="stat-value" id="strengthValue">0</div>
                        <div class="stat-hint">Use experience points to upgrade your lifting abilities.</div>
                    </div>
                </div>

                <div class="status-effects-section">
                    <div class="status-effects-title">Status Effects</div>
                    <div class="effects-list" id="effectsList">
                        <!-- Effects will be dynamically added here -->
                    </div>
                </div>
            </div>
        </div>
        
        <div class="button-container">
            <button class="lift-button" id="liftButton">
                <span>Lift</span>
                <span class="button-subtext">Tap and hold</span>
            </button>
        </div>
    </div>

    <div class="level-complete-overlay" id="levelCompleteOverlay">
        <div class="level-complete-content">
            <div class="level-complete-title">Level Complete!</div>
            <div class="level-complete-message" id="levelCompleteMessage">You've unlocked Level 2</div>
            <button class="level-complete-button" id="continueButton">Continue</button>
        </div>
    </div>

    <div class="debug-menu" id="debugMenu">
        <div class="debug-title">Debug Menu</div>
        <button class="debug-button" id="expireEffectsButton">Expire All Effects</button>
    </div>

    <script>
        const dumbbell = document.querySelector('.dumbbell');
        const liftButton = document.getElementById('liftButton');
        const strengthValue = document.getElementById('strengthValue');
        const weightValue = document.getElementById('weightValue');
        const repsValue = document.getElementById('repsValue');
        const effectsList = document.getElementById('effectsList');
        const debugMenu = document.getElementById('debugMenu');
        const expireEffectsButton = document.getElementById('expireEffectsButton');
        const leftColumn = document.getElementById('leftColumn');
        const levelCompleteOverlay = document.getElementById('levelCompleteOverlay');
        const levelCompleteMessage = document.getElementById('levelCompleteMessage');
        const continueButton = document.getElementById('continueButton');
        
        let isLifting = false;
        let isLowering = false;
        let startTime = null;
        let animationFrame = null;
        let currentPosition = 37; // Track current position - start just below rest zone
        let liftStartPosition = 37; // Track where lift started from
        let strength = 0;
        let weight = 50;
        let currentReps = 0;
        let maxReps = 5;
        let touchedRestThisRep = false;
        let justEarnedRep = false;
        let liftStartSection = null;
        let fatigueStacks = 0;
        let fatigueTimeRemaining = 0;
        let fatigueTimerInterval = null;
        let autoDropTimer = null;
        let perfectionStacks = 0;
        let perfectionTimeRemaining = 0;
        let perfectionTimerInterval = null;
        let statusEffectDefs = {};
        let levelsConfig = null;
        let currentLevel = null;
        let currentLevelNumber = 1;
        let currentHighlightedSection = null;
        let sectionOriginalTitles = new Map(); // Store original titles
        let highlightSequenceIndex = 0; // Track position in highlight sequence
        
        // Debug menu state
        const debugSequence = ['ArrowUp', 'ArrowDown', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
        let debugInput = [];

        // Load configurations
        Promise.all([
            fetch('statusEffects.json').then(r => r.json()),
            fetch('levels.json').then(r => r.json())
        ]).then(([effectsData, levelsData]) => {
            statusEffectDefs = effectsData;
            levelsConfig = levelsData;
            loadLevel(1);
        }).catch(error => console.error('Error loading configurations:', error));

        function loadLevel(levelNum) {
            const levelData = levelsConfig.levels.find(l => l.levelNumber === levelNum);
            if (!levelData) {
                console.error('Level not found:', levelNum);
                return;
            }
            
            currentLevel = levelData;
            currentLevelNumber = levelNum;
            weight = levelData.weight;
            weightValue.textContent = weight + '/500';
            
            // Reset highlight sequence
            highlightSequenceIndex = 0;
            
            maxReps = levelData.maxReps || 5;
            currentReps = 0;
            updateRepsDisplay();
            
            // Render sections
            renderSections(levelData.sections);
        }

        function renderSections(sections) {
            // Clear existing sections (but keep dumbbell)
            const dumbbellElement = leftColumn.querySelector('.dumbbell');
            leftColumn.innerHTML = '';
            
            // Create sections
            sections.forEach(section => {
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'section';
                
                if (section.type === 'perfection') {
                    sectionDiv.classList.add('perfection');
                } else if (section.type === 'rest') {
                    sectionDiv.classList.add('rest');
                }
                
                sectionDiv.setAttribute('data-type', section.type);
                
                // Apply styling
                if (section.flex) {
                    sectionDiv.style.flex = section.flex;
                } else if (section.height) {
                    sectionDiv.style.flex = '0 0 ' + section.height + 'px';
                }
                
                if (section.backgroundColor) {
                    if (section.type === 'perfection' || section.type === 'rest') {
                        sectionDiv.style.background = section.backgroundColor;
                    }
                }
                
                // Add title
                const titleDiv = document.createElement('div');
                titleDiv.className = 'section-title';
                titleDiv.textContent = section.label;
                sectionDiv.appendChild(titleDiv);
                
                // Store original title for later restoration
                sectionOriginalTitles.set(sectionDiv, section.label);
                
                // Add click handler for gains sections
                if (section.type === 'gains') {
                    sectionDiv.addEventListener('click', () => {
                        // Only respond if this section is currently highlighted
                        if (sectionDiv.classList.contains('highlighted')) {
                            highlightRandomGainsSection(sectionDiv);
                        }
                    });
                }
                
                leftColumn.appendChild(sectionDiv);
            });
            
            // Re-add dumbbell at the end
            leftColumn.appendChild(dumbbellElement);
            
            // Initialize section highlighting after DOM updates
            requestAnimationFrame(() => {
                getCurrentSection();
            });
        }

        function updateEffectsDisplay() {
            if (fatigueStacks === 0 && perfectionStacks === 0) {
                effectsList.innerHTML = `
                    <div class="effect-description" style="padding: 12px 0;">
                        You currently have no conditions that affect your lifting abilities
                    </div>
                `;
                return;
            }

            let effectsHTML = '';

            if (perfectionStacks > 0 && statusEffectDefs.perfection) {
                const def = statusEffectDefs.perfection;
                const stackText = perfectionStacks > 1 ? ` x${perfectionStacks}` : '';
                const percentage = perfectionStacks * 25;
                const description = def.description.replace('25%', `${percentage}%`);
                effectsHTML += `
                    <div class="effect-item" style="border-left-color: ${def.color};">
                        <div class="effect-header">
                            <div class="effect-name">${def.name}${stackText}</div>
                            <div class="effect-timer" id="perfectionTimer" style="color: ${def.color};">${perfectionTimeRemaining}s</div>
                        </div>
                        <div class="effect-description">${description}</div>
                    </div>
                `;
            }

            if (fatigueStacks > 0 && statusEffectDefs.fatigue) {
                const def = statusEffectDefs.fatigue;
                const stackText = fatigueStacks > 1 ? ` x${fatigueStacks}` : '';
                const percentage = Math.min(fatigueStacks * 10, 100);
                const description = def.description.replace('{percentage}', percentage);
                effectsHTML += `
                    <div class="effect-item" style="border-left-color: ${def.color};">
                        <div class="effect-header">
                            <div class="effect-name">${def.name}${stackText}</div>
                            <div class="effect-timer" id="fatigueTimer" style="color: ${def.color};">${fatigueTimeRemaining}s</div>
                        </div>
                        <div class="effect-description">${description}</div>
                    </div>
                `;
            }
            
            effectsList.innerHTML = effectsHTML;
        }

        function addFatigueStack() {
            const def = statusEffectDefs.fatigue;
            if (!def || fatigueStacks >= def.maxStacks) return;
            
            fatigueStacks++;
            fatigueTimeRemaining += def.duration;
            
            // Cap total duration at max
            if (fatigueTimeRemaining > def.maxDuration) {
                fatigueTimeRemaining = def.maxDuration;
            }
            
            updateEffectsDisplay();
            
            // Start timer if not already running
            if (!fatigueTimerInterval) {
                fatigueTimerInterval = setInterval(() => {
                    if (fatigueTimeRemaining > 0) {
                        fatigueTimeRemaining--;
                        const timerEl = document.getElementById('fatigueTimer');
                        if (timerEl) {
                            timerEl.textContent = fatigueTimeRemaining + 's';
                        }
                    } else {
                        fatigueStacks = 0;
                        clearInterval(fatigueTimerInterval);
                        fatigueTimerInterval = null;
                        updateEffectsDisplay();
                    }
                }, 1000);
            }
        }

        function addPerfectionEffect() {
            const def = statusEffectDefs.perfection;
            if (!def || perfectionStacks >= def.maxStacks) return;
            
            perfectionStacks++;
            perfectionTimeRemaining += def.duration;
            
            // Cap total duration at max
            if (perfectionTimeRemaining > def.maxDuration) {
                perfectionTimeRemaining = def.maxDuration;
            }
            
            updateEffectsDisplay();
            
            // Start timer if not already running
            if (!perfectionTimerInterval) {
                perfectionTimerInterval = setInterval(() => {
                    if (perfectionTimeRemaining > 0) {
                        perfectionTimeRemaining--;
                        const timerEl = document.getElementById('perfectionTimer');
                        if (timerEl) {
                            timerEl.textContent = perfectionTimeRemaining + 's';
                        }
                    } else {
                        perfectionStacks = 0;
                        clearInterval(perfectionTimerInterval);
                        perfectionTimerInterval = null;
                        updateEffectsDisplay();
                    }
                }, 1000);
            }
        }

        // Calculate which section the dumbbell is in
        function getCurrentSection() {
            const columnHeight = leftColumn.clientHeight;
            const positionFromTop = columnHeight - currentPosition;
            
            const sections = leftColumn.querySelectorAll('.section');
            let cumulativeHeight = 0;
            let activeSectionElement = null;
            
            for (let i = 0; i < sections.length; i++) {
                const sectionHeight = sections[i].clientHeight;
                if (positionFromTop >= cumulativeHeight && positionFromTop < cumulativeHeight + sectionHeight) {
                    activeSectionElement = sections[i];
                    const sectionType = sections[i].getAttribute('data-type');
                    
                    // Update visual indicator - remove active from all, add to current
                    sections.forEach(s => s.classList.remove('active'));
                    sections[i].classList.add('active');
                    
                    // Reset reps when rest section becomes active, unless already maxed out
                    if (sectionType === 'rest') {
                        if (currentReps > 0 && currentReps < maxReps) {
                            currentReps = 0;
                            updateRepsDisplay();
                        }
                    }
                    
                    if (sectionType === 'perfection') {
                        return 'perfection';
                    } else if (sectionType === 'fatigue') {
                        return 'fatigue';
                    } else if (sectionType === 'rest') {
                        return 'rest';
                    } else if (sectionType === 'gains') {
                        // Differentiate between first and last gains section
                        return i === 0 ? 'gains-top' : 'gains-bottom';
                    }
                }
                cumulativeHeight += sectionHeight;
            }
            
            return 'gains-bottom'; // Default
        }

        function isInGainsSection(section) {
            return section === 'gains-top' || section === 'gains-bottom';
        }

        function getGainsSections() {
            const sections = leftColumn.querySelectorAll('.section');
            const gainsSections = [];
            sections.forEach(section => {
                const type = section.getAttribute('data-type');
                if (type === 'gains') {
                    gainsSections.push(section);
                }
            });
            return gainsSections;
        }

        function highlightRandomGainsSection(excludeSection = null) {
            // Remove any existing highlights
            clearGainsHighlights();
            
            const gainsSections = getGainsSections();
            if (gainsSections.length === 0) return;
            
            // Use sequence from level config if available
            if (currentLevel && currentLevel.highlightSequence) {
                const sequence = currentLevel.highlightSequence;
                const sectionIndex = sequence[highlightSequenceIndex % sequence.length];
                
                // Move to next in sequence
                highlightSequenceIndex++;
                
                // Get the section at this index
                if (sectionIndex < gainsSections.length) {
                    const selectedSection = gainsSections[sectionIndex];
                    
                    // Highlight it
                    selectedSection.classList.add('highlighted');
                    const titleElement = selectedSection.querySelector('.section-title');
                    if (titleElement && sectionOriginalTitles.has(selectedSection)) {
                        titleElement.textContent = '→ ' + sectionOriginalTitles.get(selectedSection);
                    }
                    currentHighlightedSection = selectedSection;
                    
                    return selectedSection;
                }
            }
            
            // Fallback to old random behavior if no sequence defined
            let availableSections = gainsSections;
            if (excludeSection && gainsSections.length > 1) {
                availableSections = gainsSections.filter(s => s !== excludeSection);
            }
            
            const randomIndex = Math.floor(Math.random() * availableSections.length);
            const selectedSection = availableSections[randomIndex];
            
            selectedSection.classList.add('highlighted');
            const titleElement = selectedSection.querySelector('.section-title');
            if (titleElement && sectionOriginalTitles.has(selectedSection)) {
                titleElement.textContent = '→ ' + sectionOriginalTitles.get(selectedSection);
            }
            currentHighlightedSection = selectedSection;
            
            return selectedSection;
        }

        function clearGainsHighlights() {
            const gainsSections = getGainsSections();
            gainsSections.forEach(section => {
                section.classList.remove('highlighted');
                // Restore original title text
                const titleElement = section.querySelector('.section-title');
                if (titleElement && sectionOriginalTitles.has(section)) {
                    titleElement.textContent = sectionOriginalTitles.get(section);
                }
            });
            currentHighlightedSection = null;
        }

        function updateRepsDisplay() {
            repsValue.textContent = `${currentReps}/${maxReps}`;
        }

        function showLevelComplete() {
            const nextLevel = currentLevelNumber + 1;
            const nextLevelData = levelsConfig.levels.find(l => l.levelNumber === nextLevel);
            
            if (nextLevelData) {
                levelCompleteMessage.textContent = `Weight increased to ${nextLevelData.weight} lbs`;
            } else {
                levelCompleteMessage.textContent = `You've completed all levels!`;
            }
            
            // Fade in overlay
            levelCompleteOverlay.classList.add('visible');
        }

        function animateLift(timestamp) {
            if (!isLifting) return;
            
            if (!startTime) startTime = timestamp;
            const elapsed = timestamp - startTime;
            
            // Calculate max height considering fatigue
            const baseMaxHeight = window.innerHeight - 100;
            const minHeight = 75;
            const totalLiftableDistance = baseMaxHeight - minHeight;
            const fatigueReduction = Math.min(fatigueStacks * 10, 100) / 100; // 10% per stack, max 100%
            const maxLiftableDistance = totalLiftableDistance * (1 - fatigueReduction);
            const endPos = minHeight + maxLiftableDistance;
            
            const distanceToTravel = endPos - liftStartPosition;
            const totalDistance = baseMaxHeight - 75;
            const duration = 1500 * (distanceToTravel / totalDistance); // Scale duration to remaining distance
            
            let progress = Math.min(elapsed / duration, 1);
            progress = 1 - Math.pow(1 - progress, 3); // Cubic ease-out for smooth motion
            
            // Move from lift start position to max allowed position
            currentPosition = liftStartPosition + (endPos - liftStartPosition) * progress;
            
            // Clamp to never exceed the maximum allowed position (prevents rapid tap exploit)
            currentPosition = Math.min(currentPosition, endPos);
            
            dumbbell.style.bottom = `${currentPosition}px`;
            
            // Update section highlighting in realtime
            getCurrentSection();
            
            if (progress < 1) {
                animationFrame = requestAnimationFrame(animateLift);
            } else {
                // Bar has reached the top, start 1-second timer for auto-drop
                if (!autoDropTimer && isLifting) {
                    autoDropTimer = setTimeout(() => {
                        stopLift();
                    }, 1000);
                }
            }
        }

        function animateLower(timestamp) {
            if (!isLowering) return;
            
            if (!startTime) startTime = timestamp;
            const elapsed = timestamp - startTime;
            
            // Use ease-in cubic for smooth acceleration downward
            const duration = 1125; // 1.125 seconds to return to bottom
            let progress = Math.min(elapsed / duration, 1);
            progress = Math.pow(progress, 2); // Quadratic ease-in for smooth drop
            
            // Move from current position back to 37px (just below rest position)
            const startPos = currentPosition;
            const endPos = 37;
            currentPosition = startPos + (endPos - startPos) * progress;
            
            dumbbell.style.bottom = `${currentPosition}px`;
            
            // Update section highlighting in realtime during drop
            getCurrentSection();
            
            if (progress < 1) {
                animationFrame = requestAnimationFrame(animateLower);
            } else {
                isLowering = false;
                currentPosition = 37;
                touchedRestThisRep = false;
                justEarnedRep = false; // Clear the flag for next lift
                
                // Clear highlights when dumbbell returns to rest
                clearGainsHighlights();
            }
        }

        function startLift() {
            // Cancel any ongoing animation
            if (animationFrame) cancelAnimationFrame(animationFrame);
            
            // Clear auto-drop timer if exists
            if (autoDropTimer) {
                clearTimeout(autoDropTimer);
                autoDropTimer = null;
            }
            
            // Reset touched rest flag at start of each lift
            touchedRestThisRep = false;
            
            // Check if starting in Fatigue section
            const startSection = getCurrentSection();
            if (startSection === 'fatigue') {
                addFatigueStack();
            } else if (startSection === 'perfection') {
                addPerfectionEffect();
            } else if (startSection === 'rest') {
                touchedRestThisRep = true;
            }
            
            // Add visual feedback
            liftButton.classList.add('lifting');
            dumbbell.classList.add('shaking');
            
            // Record which section we're starting in
            liftStartSection = startSection;
            
            // Highlight a gains section when starting lift
            highlightRandomGainsSection(currentHighlightedSection);
            
            // Start lifting from current position
            isLifting = true;
            isLowering = false;
            startTime = null;
            liftStartPosition = currentPosition; // Resume from wherever we are now
            
            animationFrame = requestAnimationFrame(animateLift);
        }

        function stopLift() {
            if (animationFrame) cancelAnimationFrame(animationFrame);
            
            // Clear auto-drop timer if exists
            if (autoDropTimer) {
                clearTimeout(autoDropTimer);
                autoDropTimer = null;
            }
            
            // Remove lifting state
            liftButton.classList.remove('lifting');
            dumbbell.classList.remove('shaking');
            
            // Highlight a different gains section when releasing
            highlightRandomGainsSection(currentHighlightedSection);
            
            // Check if we released in Fatigue section
            const releaseSection = getCurrentSection();
            if (releaseSection === 'fatigue') {
                addFatigueStack();
            } else if (releaseSection === 'perfection') {
                addPerfectionEffect();
            } else if (releaseSection === 'rest') {
                touchedRestThisRep = true;
            }
            
            // Check if we started and ended in different Gains sections
            const earnedRep = isInGainsSection(liftStartSection) && 
                isInGainsSection(releaseSection) && 
                liftStartSection !== releaseSection &&
                !touchedRestThisRep; // Can't earn rep if touched rest
            
            justEarnedRep = earnedRep; // Track for rest reset logic
            
            if (earnedRep && currentReps < maxReps) {
                let xpGain = currentLevel ? currentLevel.baseXP : 5;
                if (perfectionStacks > 0) {
                    xpGain = Math.floor(xpGain * (1 + (perfectionStacks * 0.25))); // 25% bonus per stack
                }
                strength += xpGain;
                strengthValue.textContent = strength;
                
                // Add XP gain animation
                strengthValue.classList.add('xp-gain');
                setTimeout(() => {
                    strengthValue.classList.remove('xp-gain');
                }, 500);
                
                // Count rep
                currentReps++;
                updateRepsDisplay();
                
                // Check if level complete
                if (currentReps >= maxReps) {
                    setTimeout(() => {
                        showLevelComplete();
                    }, 800); // Delay to let XP animation finish
                }
                
                // Add success feedback
                liftButton.classList.add('success');
                setTimeout(() => {
                    liftButton.classList.remove('success');
                }, 400);
            }
            
            // Reset rest touch flag for next rep
            touchedRestThisRep = false;
            
            // Start lowering from current position
            isLifting = false;
            isLowering = true;
            startTime = null;
            
            animationFrame = requestAnimationFrame(animateLower);
        }

        // Mouse events
        liftButton.addEventListener('mousedown', startLift);
        liftButton.addEventListener('mouseup', stopLift);
        liftButton.addEventListener('mouseleave', () => {
            // Only stop if actually lifting to handle drag-off case
            // but don't change highlights for mouseleave
            if (isLifting) {
                if (animationFrame) cancelAnimationFrame(animationFrame);
                if (autoDropTimer) {
                    clearTimeout(autoDropTimer);
                    autoDropTimer = null;
                }
                liftButton.classList.remove('lifting');
                dumbbell.classList.remove('shaking');
                isLifting = false;
                isLowering = true;
                startTime = null;
                animationFrame = requestAnimationFrame(animateLower);
            }
        });

        // Touch events
        liftButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startLift();
        });
        liftButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopLift();
        });
        liftButton.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            stopLift();
        });

        // Debug menu keyboard sequence detection
        document.addEventListener('keydown', (e) => {
            debugInput.push(e.key);
            
            // Keep only the last 6 keys
            if (debugInput.length > debugSequence.length) {
                debugInput.shift();
            }
            
            // Check if sequence matches
            if (debugInput.length === debugSequence.length) {
                const matches = debugInput.every((key, index) => key === debugSequence[index]);
                if (matches) {
                    debugMenu.classList.toggle('visible');
                    debugInput = []; // Reset sequence
                }
            }
        });

        // Expire all effects button
        expireEffectsButton.addEventListener('click', () => {
            fatigueTimeRemaining = 0;
            fatigueStacks = 0;
            if (fatigueTimerInterval) {
                clearInterval(fatigueTimerInterval);
                fatigueTimerInterval = null;
            }
            perfectionTimeRemaining = 0;
            perfectionStacks = 0;
            if (perfectionTimerInterval) {
                clearInterval(perfectionTimerInterval);
                perfectionTimerInterval = null;
            }
            updateEffectsDisplay();
        });

        // Continue button handler
        continueButton.addEventListener('click', () => {
            levelCompleteOverlay.classList.remove('visible');
            const nextLevel = currentLevelNumber + 1;
            const nextLevelData = levelsConfig.levels.find(l => l.levelNumber === nextLevel);
            
            if (nextLevelData) {
                loadLevel(nextLevel);
            } else {
                // No more levels, restart from level 1 or show completion
                loadLevel(1);
            }
        });

        // Initialize display on page load
        updateEffectsDisplay();
    </script>
</body>
</html>